"""
Module for reading and writing trajectory related files
"""
from typing import Dict, List
import numpy as np
import os
import csv
from mathutils import Vector, Quaternion
import subprocess

# Target model
SHAPE_MODEL_FILENAME = "../models/integral.obj"

camera_trajectory_header = [
        "# camera_traj_v2.txt (inertial frame reference - orbital configuration)",
        "# p_G_I(xyz)  q_I_G(wxyz)  p_C_I(xyz)  q_I_C(wxyz)  sun_az  sun_el",
        "# Trajectory generated by the generateTrajectoriesUnified.py script",
        "# Earth/atmosphere at origin with fixed orientation",
        "#"
    ]

def write_camera_trajectory(output_dir: str,
                            nbSteps: int,
                            timestamps: np.ndarray,
                            r_GO_I: np.ndarray, # vector from O to G in inertial frame
                            q_IG: np.ndarray, # quaternion from G to I
                            r_CO_I: np.ndarray, # vector from O to C in inertial frame
                            q_IC: np.ndarray, # quaternion from C to I
                            sun_az_I: np.ndarray,
                            sun_el_I: np.ndarray,
                            ) -> str:
    """
    Write camera trajectory CSV with inertial-frame variables.
    a data structure to hold everything may be a good idea

    CSV columns:
    timestamp,
    p_G_I_x, p_G_I_y, p_G_I_z,
    q_I_G_w, q_I_G_x, q_I_G_y, q_I_G_z,
    p_C_I_x, p_C_I_y, p_C_I_z,
    q_I_C_w, q_I_C_x, q_I_C_y, q_I_C_z,
    sun_az, sun_el

    Note the frame conventions here follow the Trajectory generation standard
    
    Where:
      p_G_I = position of target (G) in inertial frame at radius R_LEO
      q_I_G = orientation of target frame relative to inertial
      p_C_I = position of camera (C) in inertial frame at radius (R_LEO + R_RPO)
      q_I_C = orientation of camera frame relative to inertial
    """
    camera_traj_filepath = os.path.join(output_dir, "camera_traj.csv")

    p_G_I = -np.asarray(r_GO_I[:nbSteps], dtype=float)
    q_I_G = np.asarray(q_IG[:nbSteps], dtype=float)
    p_C_I = -np.asarray(r_CO_I[:nbSteps], dtype=float)
    q_I_C = np.asarray(q_IC[:nbSteps], dtype=float)
    sun_az = np.asarray(sun_az_I[:nbSteps], dtype=float)
    sun_el = np.asarray(sun_el_I[:nbSteps], dtype=float)

    header = [
        "timestamp",
        "p_G_I_x", "p_G_I_y", "p_G_I_z",
        "q_I_G_w", "q_I_G_x", "q_I_G_y", "q_I_G_z",
        "p_C_I_x", "p_C_I_y", "p_C_I_z",
        "q_I_C_w", "q_I_C_x", "q_I_C_y", "q_I_C_z",
        "sun_az", "sun_el",
    ]

    with open(camera_traj_filepath, "w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(header)
        for i in range(nbSteps):
            writer.writerow([
                timestamps[i],
                p_G_I[i, 0], p_G_I[i, 1], p_G_I[i, 2],
                q_I_G[i, 0], q_I_G[i, 1], q_I_G[i, 2], q_I_G[i, 3],
                p_C_I[i, 0], p_C_I[i, 1], p_C_I[i, 2],
                q_I_C[i, 0], q_I_C[i, 1], q_I_C[i, 2], q_I_C[i, 3],
                sun_az[i], sun_el[i],
            ])

    return camera_traj_filepath

def read_camera_trajectory(file_path: str) -> Dict[str, np.ndarray]:
    """
    Read camera trajectory CSV and return NumPy arrays in dictionary.
    
    CSV columns:
    timestamp,
    p_G_I_x, p_G_I_y, p_G_I_z,
    q_I_G_w, q_I_G_x, q_I_G_y, q_I_G_z,
    p_C_I_x, p_C_I_y, p_C_I_z,
    q_I_C_w, q_I_C_x, q_I_C_y, q_I_C_z,
    sun_az, sun_el

    Note the frame conventions here follow the Trajectory generation standard
    
    Where:
      p_G_I = position of target (G) in inertial frame at radius R_LEO
      q_I_G = orientation of target frame relative to inertial
      p_C_I = position of camera (C) in inertial frame at radius (R_LEO + R_RPO)
      q_I_C = orientation of camera frame relative to inertial
    """
    required_cols = [
        "timestamp",
        "p_G_I_x", "p_G_I_y", "p_G_I_z",
        "q_I_G_w", "q_I_G_x", "q_I_G_y", "q_I_G_z",
        "p_C_I_x", "p_C_I_y", "p_C_I_z",
        "q_I_C_w", "q_I_C_x", "q_I_C_y", "q_I_C_z",
        "sun_az", "sun_el",
    ]

    rows = []
    with open(file_path, "r", newline="") as f:
        reader = csv.DictReader(f)
        if reader.fieldnames is None:
            raise ValueError(f"CSV file has no header: {file_path}")
        missing = [c for c in required_cols if c not in reader.fieldnames]
        if missing:
            raise ValueError(f"Missing columns in camera trajectory CSV: {missing}")
        rows = list(reader)

    trajectory = {
        "timestamps": np.array([float(r["timestamp"]) for r in rows], dtype=float),
        "p_G_I": np.array([[float(r["p_G_I_x"]), float(r["p_G_I_y"]), float(r["p_G_I_z"])] for r in rows], dtype=float),
        "q_I_G": np.array([[float(r["q_I_G_w"]), float(r["q_I_G_x"]), float(r["q_I_G_y"]), float(r["q_I_G_z"])] for r in rows], dtype=float),
        "p_C_I": np.array([[float(r["p_C_I_x"]), float(r["p_C_I_y"]), float(r["p_C_I_z"])] for r in rows], dtype=float),
        "q_I_C": np.array([[float(r["q_I_C_w"]), float(r["q_I_C_x"]), float(r["q_I_C_y"]), float(r["q_I_C_z"])] for r in rows], dtype=float),
        "sun_az": np.array([float(r["sun_az"]) for r in rows], dtype=float),
        "sun_el": np.array([float(r["sun_el"]) for r in rows], dtype=float),
    }

    required_keys = ("timestamps", "p_G_I", "q_I_G", "p_C_I", "q_I_C", "sun_az", "sun_el")
    lengths = [len(trajectory[k]) for k in required_keys]
    if len(set(lengths)) != 1:
        raise ValueError(f"Inconsistent trajectory lengths across keys: {dict(zip(required_keys, lengths))}")

    trajectory["N"] = np.array(lengths[0], dtype=int)
    return trajectory

def get_scaled_trajectory_in_ECI(trajectory: Dict[str, np.ndarray], earth_dist_scale_factor: float = 1/1000) -> Dict[str, np.ndarray]:
    """
    Scale the trajectory's positions by earth_dist_scale_factor to bring it closer to Earth, while keeping the relative transformations between camera and target the same.

    Args:
        trajectory: Dictionary containing trajectory data with keys "N", "timestamps", "p_G_I", "q_I_G", "p_C_I", "q_I_C", "sun_az", "sun_el".
        earth_dist_scale_factor: Factor to scale the positions by. For example, 1/1000 will bring a 1000 km orbit down to 1 km.
    """
    nbTruePts = trajectory["N"]
    timestamps = trajectory["timestamps"]
    p_G_I = trajectory["p_G_I"]
    q_I_G = trajectory["q_I_G"]
    p_C_I = trajectory["p_C_I"]
    q_I_C = trajectory["q_I_C"]
    sun_az = trajectory["sun_az"]
    sun_el = trajectory["sun_el"]

    # Modify orbits
    # Bring the orbit closer to the earth but keep the relative transformation between the camera and the target the same
    r_GC_I = p_G_I - p_C_I  # Vector from C to G in inertial frame
    p_C_I_scaled = p_C_I * earth_dist_scale_factor
    p_G_O_scaled = p_C_I_scaled + r_GC_I

    # Modify the orientations
    q_IG = q_I_G  # Target orientation relative to inertial stays the same

    return {
        "N": nbTruePts,
        "t": timestamps,
        "q_IC": q_I_C,
        "q_IG": q_IG,
        "p_C_I": p_C_I_scaled,
        "p_G_I": p_G_O_scaled,
        "sun_az": sun_az,
        "sun_el": sun_el
    }

def make_frames_from_trajectory(
    trajectory: Dict[str, np.ndarray],
    debug_camera_orientation: bool = False,
    num_samples_on_axis: int = 4,
) -> List[Dict]:
    frames = []

    if num_samples_on_axis < 1:
        raise ValueError("num_samples_on_axis must be >= 1")

    # Skip 0 rad because the base frame is always included unchanged.
    debug_angles = np.linspace(0.0, 2.0 * np.pi, num_samples_on_axis, endpoint=False)[1:]

    for i in range(trajectory["N"]):
        frame = {
            "p_G_I": trajectory["p_G_I"][i],
            "q_I_G": trajectory["q_IG"][i],
            "p_C_I": trajectory["p_C_I"][i],
            "q_I_C": trajectory["q_IC"][i],
            "sun_az": trajectory["sun_az"][i],
            "sun_el": trajectory["sun_el"][i]
        }
        frames.append(frame)
        if debug_camera_orientation:
            # Generate additional camera orientations around local X/Y only.
            # Do not rotate around local forward axis (-Z), because that does
            # not change the visible scene content.
            q_IC = Quaternion(tuple(trajectory["q_IC"][i]))
            for axis in ((1.0, 0.0, 0.0), (0.0, 1.0, 0.0)):
                for angle in debug_angles:
                    q_CCprime = Quaternion(axis, float(angle))
                    q_variant = (q_IC @ q_CCprime).normalized()
                    frames.append({
                        "p_G_I": trajectory["p_G_I"][i],
                        "q_I_G": trajectory["q_IG"][i],
                        "p_C_I": trajectory["p_C_I"][i],
                        "q_I_C": np.array([q_variant.w, q_variant.x, q_variant.y, q_variant.z], dtype=float),
                        "sun_az": trajectory["sun_az"][i],
                        "sun_el": trajectory["sun_el"][i]
                    })
            
    return frames

def write_gtvalues(output_dir: str,
                    nbSteps: int,
                    timestamps: np.ndarray,
                    J: np.ndarray,
                    r_AG_G: np.ndarray,
                    q_GC: np.ndarray,
                    q_IG: np.ndarray,
                    q_IC: np.ndarray,
                    omega_GI_G: np.ndarray,
                    omega_CI_C: np.ndarray,
                    r_CG_G: np.ndarray,
                    v_CG_G: np.ndarray,
                    r_OG_G: np.ndarray,
                    az_G: np.ndarray,
                    el_G: np.ndarray,
                    state_A_I: np.ndarray,
                    r_GO_I: np.ndarray,
                    v_GO_I: np.ndarray, 
                    state_C_I: np.ndarray):
    # --- gtValues.txt ---
    gtvalues_filepath = os.path.join(output_dir, "gtValues.txt")
    with open(gtvalues_filepath, "w") as f:
        f.write("nSamples = \n")
        f.write(f"{nbSteps}\n")
        f.write("timestamps = \n")
        np.savetxt(f, timestamps, fmt="%f")

        # Inertia tensor at COM (frame A), trace-normalized, 5-parameter format
        # Format: Ixx Iyy Ixy Ixz Iyz (Izz = 1 - Ixx - Iyy from trace constraint)
        # This is the target's inertia tensor used in Euler dynamics propagation.
        # The inertia is expressed in body-fixed frame A (COM frame).
        trace_J = np.trace(J)
        J_norm = J / trace_J
        inertia_5 = np.array([J_norm[0, 0], J_norm[1, 1],
                                J_norm[0, 1], J_norm[0, 2], J_norm[1, 2]])
        f.write("inertia_A = \n")
        f.write(f"{inertia_5[0]:.9f} {inertia_5[1]:.9f} {inertia_5[2]:.9f} {inertia_5[3]:.9f} {inertia_5[4]:.9f}\n")

        # r_AG_G: COM position relative to G-frame origin, in G coords
        # SIGN CONVENTION: Per LaTeX, r_YX = Y - X (vector from X to Y)
        # r_AG_G = A - G (position of A relative to G, vector from G to A)
        # Internal variable r_AG_G_used stores G - A, so negate for output
        f.write("r_AG_G = \n")
        r_AG_G_output = -r_AG_G  # Convert from internal G-A to convention A-G
        f.write(f"{r_AG_G_output[0]:.9f} {r_AG_G_output[1]:.9f} {r_AG_G_output[2]:.9f}\n")

        f.write("q_GS = \n")
        np.savetxt(f, q_GC, fmt="%f %f %f %f")
        f.write("q_IG = \n")
        np.savetxt(f, q_IG, fmt="%f %f %f %f")
        f.write("q_IS = \n")
        np.savetxt(f, q_IC, fmt="%f %f %f %f")

        # SIGN CONVENTION (omega_GI_G):
        # solve_ne_equation uses standard kinematics: R_{k+1} = R_k @ exp(sk(ω·dt))
        # where ω is the body angular velocity ω_GI^G from Newton-Euler equations.
        # This corresponds to dR_IG/dt = R_IG @ sk(ω_GI^G), which is the standard
        # textbook convention. No sign flip needed - output directly.
        f.write("omega_GI_G = \n")
        np.savetxt(f, omega_GI_G, fmt="%f %f %f")
        # SIGN CONVENTION (omega_SI_S):
        # Factor expects ω_SI^S = angular velocity of S wrt I, expressed in S.
        #
        # omega_CI_C is computed using the angular velocity addition formula:
        #   ω_IC^C = ω_IG^C + ω_GC^C
        # where:
        #   ω_IG^C = -R_CG @ ω_GI^G (sign flip: I-wrt-G = -(G-wrt-I))
        #   ω_GC^C = -omega_GC_C (variable stores ω_CG^C from finite differences)
        #
        # The variable omega_CI_C stores ω_IC^C (I wrt C, in C).
        # Output -omega_CI_C = ω_CI^C = ω_SI^S (since C = S).
        f.write("omega_SI_S = \n")
        np.savetxt(f, -omega_CI_C, fmt="%f %f %f")

        # SIGN CONVENTION: Per LaTeX, r_YX = Y - X (vector from X to Y)
        # r_SG = S - G, and since C = S (chaser = spacecraft): r_SG = r_CG = C - G
        # r_CG_G is computed correctly as C - G, so output directly (no negation)
        f.write("r_SG_G = \n")
        np.savetxt(f, r_CG_G, fmt="%f %f %f")
        f.write("v_SG_G = \n")
        np.savetxt(f, v_CG_G, fmt="%f %f %f")

        f.write("r_OG_G = \n")
        np.savetxt(f, r_OG_G, fmt="%f %f %f")
        f.write("sun_az_el = \n")
        for j in range(nbSteps):
            f.write(f"{az_G[j]:.6f} {el_G[j]:.6f}\n")

        # SIGN CONVENTION: Per LaTeX, r_YX = Y - X (vector from X to Y)
        # r_SA = S - A (position of S relative to A, i.e., vector from A to S)
        r_SA_I_data = state_C_I[:, 0:3] - state_A_I[:, 0:3]  # S - A
        v_SA_I_data = state_C_I[:, 3:6] - state_A_I[:, 3:6]  # v_S - v_A
        f.write("r_SA_I = \n")
        np.savetxt(f, r_SA_I_data, fmt="%f %f %f")
        f.write("v_SA_I = \n")
        np.savetxt(f, v_SA_I_data, fmt="%f %f %f")

        f.write("r_AO_I = \n")
        np.savetxt(f, state_A_I[:, 0:3], fmt="%f %f %f")
        f.write("v_AO_I = \n")
        np.savetxt(f, state_A_I[:, 3:6], fmt="%f %f %f")

        f.write("r_GO_I = \n")
        np.savetxt(f, r_GO_I, fmt="%f %f %f")
        f.write("v_GO_I = \n")
        np.savetxt(f, v_GO_I, fmt="%f %f %f")
    print(f"  [GTVAL]   {gtvalues_filepath}")
    return gtvalues_filepath

def write_config(output_dir: str,
                    nbSteps: int,
                    camera_obj: dict,
                    tstep_eff: float,
                    child_ss: np.random.SeedSequence,
                    path_mode: str,
                    rotMode_Gframe: str,
                    agent_idx: int,
                    mu_ref: float,
                    h_orbit: float,
                    tend: float,
                    inc: float,
                    ecc: float):
    # --- Config.yaml (OpenCV-style YAML for SatSLAM) ---
    config_filepath = os.path.join(output_dir, "Config.yaml")
    with open(config_filepath, "w") as f:
        # Camera intrinsics from camera_obj
        focal_length = camera_obj["focal_length_px"]
        res_x, res_y = camera_obj["resolution"]
        cx = res_x / 2.0
        cy = res_y / 2.0
        fps = 1.0 / tstep_eff

        f.write("%YAML:1.0\n\n")

        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("# Filenames to load\n")
        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("ImageList.Filename: imgList.txt\n")
        f.write("GroundTruth.Filename: gtValues.txt\n")
        f.write("SensorMeasurements.Filename: sensormeasurements.txt\n")
        f.write(f"ShapeModel.Filename: {SHAPE_MODEL_FILENAME}\n")
        f.write("ShapeModel.ScaleFactor: 1.0\n\n")

        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("# Experimentation Parameters\n")
        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("Settings.runExperiments: 0\n\n")

        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("# General Parameters\n")
        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("Settings.IsAsync: 0\n")
        f.write("Settings.ActiveVisualizer: 0\n")
        f.write("Settings.ActiveRecord: 0\n")
        f.write("Settings.ActiveBackEnd: 1\n")
        f.write("Settings.ActiveLoopClosure: 1\n")
        f.write("Settings.ActiveMesher: 0\n")
        f.write("Settings.ActiveLines: 0\n")
        f.write("Settings.EmptyQueueBeforeTerminate: 0\n")
        f.write("Settings.HasGT: 1\n")
        f.write("Settings.UseGT: 0\n")
        f.write("Settings.StartIdx: 0\n")
        f.write(f"Settings.EndIdx: {nbSteps}\n")
        f.write("Settings.InitialOffset: 0\n")
        f.write("Settings.nFramesInit: 6\n")
        f.write("Settings.DownsampleFactor: 1\n\n")

        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("# Camera Parameters\n")
        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("Camera.R_CS_r11: 1.0\n")
        f.write("Camera.R_CS_r12: 0.0\n")
        f.write("Camera.R_CS_r13: 0.0\n")
        f.write("Camera.R_CS_r21: 0.0\n")
        f.write("Camera.R_CS_r22: 1.0\n")
        f.write("Camera.R_CS_r23: 0.0\n")
        f.write("Camera.R_CS_r31: 0.0\n")
        f.write("Camera.R_CS_r32: 0.0\n")
        f.write("Camera.R_CS_r33: 1.0\n")
        f.write(f"Camera.fx: {focal_length}\n")
        f.write(f"Camera.fy: {focal_length}\n")
        f.write(f"Camera.cx: {cx}\n")
        f.write(f"Camera.cy: {cy}\n")
        f.write("Camera.k1: 0.0\n")
        f.write("Camera.k2: 0.0\n")
        f.write("Camera.p1: 0.0\n")
        f.write("Camera.p2: 0.0\n")
        f.write("Camera.k3: 0.0\n")
        f.write(f"Camera.fps: {fps:.1f}\n")
        f.write("Camera.RGB: 0\n")
        f.write(f"Camera.resolution: [{res_x}, {res_y}]\n")
        f.write("Image.FITSValueScale: 22.849\n\n")

        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("# Front-End Parameters\n")
        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("FrontEnd.kfInterval: 7\n")
        f.write("FrontEnd.matcherWindowAndCandidates: [1, 1]\n")
        f.write("FrontEnd.minInlierPercentage: 0.75\n")
        f.write("FrontEnd.minInliersToLastKF: 30\n")
        f.write("FrontEnd.minInliers: 8\n")
        f.write("FrontEnd.knnK: 1\n")
        f.write("FrontEnd.loweRatio: 0.75\n")
        f.write("FrontEnd.ransacReprojThreshold: 6.0\n")
        f.write("FrontEnd.ransacConfidence: 0.999\n")
        f.write("FrontEnd.minBaselinePx: 1e6\n\n")

        f.write("# KF Selection: 0=FIXED_INTERVAL, 1=GEOMETRY_AWARE\n")
        f.write("FrontEnd.kfMode: 1\n")
        f.write("FrontEnd.geoMinGap: 5\n")
        f.write("FrontEnd.geoMaxGap: 70\n")
        f.write("FrontEnd.geoMinParallaxDeg: 0.30\n")
        f.write("FrontEnd.geoParallaxHiMargin: 0.25\n")
        f.write("FrontEnd.geoParallaxHiMax: 0.65\n")
        f.write("FrontEnd.geoMaxRotationDominance: 0.40\n")
        f.write("FrontEnd.geoMinAvgTrackLength: 3.0\n\n")

        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("# ORB Parameters\n")
        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("ORBextractor.nFeatures: 1450\n")
        f.write("ORBextractor.scaleFactor: 1.25\n")
        f.write("ORBextractor.nLevels: 7\n")
        f.write("ORBextractor.edgeThreshold: 10\n")
        f.write("ORBextractor.patchSize: 31\n")
        f.write("ORBextractor.fastThreshold: 14\n")
        f.write("ORBextractor.minFastThreshold: 4\n\n")

        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("# Line Parameters\n")
        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("Line.minlength: 1.0\n\n")

        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("# Back-End Parameters\n")
        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("BackEnd.useRelDyn: 1\n")
        f.write("Backend.minTriangulationAngleDeg: 0.5\n")
        f.write("BackEnd.enableLandmarkFiltering: 1\n")
        f.write("BackEnd.iSAMRelinearizationThresh: 0.1\n")
        f.write("BackEnd.iSAMRelinearizationSkip: 1\n")
        f.write("BackEnd.iSAMcacheLinearizedFactors: 0\n")  # False for accuracy
        f.write("BackEnd.iSAMfindUnusedFactorSlots: 1\n")  # True for memory efficiency
        f.write("BackEnd.iSAMfactorization: QR\n")  # QR for numerical stability
        f.write("BackEnd.wildfire_threshold: 0.01\n")
        f.write("BackEnd.numOptimize: 1\n")
        f.write("BackEnd.optimizationWindowSec: 60\n")
        f.write("BackEnd.iSAMevaluateNonlinearError: 0\n")
        f.write("BackEnd.iSAMenableDetailedResults: 0\n")
        f.write("BackEnd.SfSMalpha: 1.0\n")
        f.write("Prior.Q_sigmas: [0.01, 0.01, 0.01]\n")
        f.write("Prior.r_sigmas: [0.1, 0.1, 1.0]\n\n")

        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("# RelDyn Parameters\n")
        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("RelDynFactor.nStages: 5\n")
        f.write("RelDynFactor.ninc: 16\n")
        f.write("RelDynFactor.LU: 1.0\n")
        f.write("RelDynFactor.TU: 1.0\n")
        f.write(f"RelDynFactor.muEarth: {mu_ref}\n")
        f.write("RelDynFactor.usePreviousMeasurement: 1\n")
        # Noise parameters - names and values match validated test (convergence-test-body.h)
        f.write("RelDynFactor.relDynProcessNoiseSigmas: [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.005, 0.005, 0.005]\n")
        f.write("RelDynFactor.omegaPriorSigmas: [0.01, 0.01, 0.01]\n")
        f.write("RelDynFactor.inertiaPriorSigmas: [1.0, 1.0, 0.1, 0.1, 0.1]\n")
        f.write("RelDynFactor.comPriorSigmas: [1.0, 1.0, 1.0]\n")
        f.write("RelDynFactor.rSAIAnchorSigmas: [0.01, 0.01, 0.01]\n")
        f.write("RelDynFactor.velocityPriorSigmas: [0.5, 0.5, 0.5]\n")
        f.write("RelDynFactor.ipcFactorSigmas: [0.04, 0.04, 0.04]\n")
        f.write("RelDynFactor.angMomFactorSigmas: [0.01, 0.01, 0.01]\n\n")

        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("# Loop-Closure Parameters\n")
        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("LoopClosure.ignoredFramesWindow: 10\n")
        f.write("LoopClosure.defaultMinScore: 0.1\n")
        f.write("LoopClosure.loweRatio: 0.75\n")
        f.write("LoopClosure.minInliers: 6\n")
        f.write("LoopClosure.minSharedWords: 3\n")
        f.write("LoopClosure.commonWordsRatio: 0.8\n")
        f.write("LoopClosure.ransacReprojThreshold: 1.0\n")
        f.write("LoopClosure.ransacConfidence: 0.99\n")
        f.write("LoopClosure.knnK: 1\n")
        f.write("LoopClosure.pgoTriggerPeriod: 50\n\n")

        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("# Viewer Parameters\n")
        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("Viewer.KeyFrameSize: 0.05\n")
        f.write("Viewer.KeyFrameLineWidth: 1\n")
        f.write("Viewer.GraphLineWidth: 0.9\n")
        f.write("Viewer.PointSize: 2\n")
        f.write("Viewer.CameraSize: 0.08\n")
        f.write("Viewer.CameraLineWidth: 3\n")
        f.write("Viewer.ViewpointX: -100.0\n")
        f.write("Viewer.ViewpointY: 100.0\n")
        f.write("Viewer.ViewpointZ: 100.0\n")
        f.write("Viewer.ViewpointF: 500\n")
        f.write("Viewer.TriadScale: 1\n")
        f.write("Viewer.Width: 1920\n")
        f.write("Viewer.Height: 1080\n")
        f.write("Viewer.clipNear: 0.1\n")
        f.write("Viewer.clipFar: 1000\n")
        f.write("Viewer.fov: 45\n")
        f.write("Viewer.DrawObject: 1\n")
        f.write("Viewer.LightPower: 20.0\n\n")

        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("# Depth Simulator Parameters\n")
        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("Simulator.clipNear: 0.1\n")
        f.write("Simulator.clipFar: 4000\n")
        f.write("Simulator.DrawObject: 1\n")
        f.write("Simulator.LightPower: 20.0\n\n")

        # Add trajectory generation metadata as comments
        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write("# Trajectory Generation Metadata (for reference only)\n")
        f.write("#--------------------------------------------------------------------------------------------\n")
        f.write(f"# master_seed: {int(child_ss.entropy)}\n")
        f.write(f"# mc_index: {child_ss.spawn_key[0]}\n")
        f.write(f"# path_mode: {path_mode.title()}\n")
        f.write(f"# rotMode_Gframe: {rotMode_Gframe}\n")
        f.write(f"# agent_id: {agent_idx}\n")
        f.write(f"# mu_ref: {mu_ref}\n")
        f.write(f"# h_orbit: {h_orbit}\n")
        f.write(f"# tend: {tend}\n")
        f.write(f"# tstep: {tstep_eff}\n")
        f.write(f"# inc: {inc}\n")
        f.write(f"# ecc: {ecc}\n")

    print(f"  [CONFIG]  {config_filepath}")

def write_sensormeasurements(output_dir: str,
                                nbSteps: int,
                                timestamps: np.ndarray,
                                q_IC_m: np.ndarray,
                                omega_CI_C_m: np.ndarray,
                                state_A_I: np.ndarray,
                                state_C_I: np.ndarray,
                                f_specific_S_m: np.ndarray,
                                tau_specific_S: np.ndarray,):
    # --- sensormeasurements.txt ---
    sensor_filepath = os.path.join(output_dir, "sensormeasurements.txt")
    with open(sensor_filepath, "w") as f:
        f.write("nSamples = \n")
        f.write(f"{nbSteps}\n")
        f.write("timestamps = \n")
        np.savetxt(f, timestamps, fmt="%f")
        f.write("q_IS_m = \n")
        np.savetxt(f, q_IC_m, fmt="%f %f %f %f")
        # Same sign convention as gtValues.txt: negate omega_CI_C to get ω_SI^S
        # (see detailed comment in gtValues.txt section above)
        f.write("omega_SI_S_m = \n")
        np.savetxt(f, -omega_CI_C_m, fmt="%f %f %f")
        f.write("r_AO_I = \n")
        np.savetxt(f, state_A_I[:, 0:3], fmt="%f %f %f")
        f.write("f_s_S_m = \n")
        np.savetxt(f, f_specific_S_m, fmt="%f %f %f")
        f.write("tau_s_S = \n")
        np.savetxt(f, tau_specific_S, fmt="%f %f %f")
        # Ephemeris-based r_SA_I measurement (S relative to A in inertial frame)
        # r_SA = S - A (vector from target COM to chaser)
        r_SA_I_meas = state_C_I[:, 0:3] - state_A_I[:, 0:3]
        f.write("r_SA_I_meas = \n")
        np.savetxt(f, r_SA_I_meas, fmt="%f %f %f")
    print(f"  [SENSOR]  {sensor_filepath}")

def rename_imgs_in_folder(folder):

    # Iterate over files in the directory
    for filename in os.listdir(folder):
        # Check if the file starts with 'simulator_image_' and ends with '.png'
        if filename.endswith(".png"):
            # Extract the number from the original filename
            number = filename.split('_')[-1].split('.')[0]
            # Create the new filename with leading zeros
            new_filename = f"img_{int(number):04d}.png"

            # Get full paths
            old_file = os.path.join(folder, filename)
            new_file = os.path.join(folder, new_filename)
            
            # Rename the file
            os.rename(old_file, new_file)

def create_ffmpeg(gt_output, filename):
    parent_directory = os.path.dirname(gt_output)
    output_video = os.path.join(parent_directory, filename + '.mp4')
    print(f"Creating video {output_video} from images in {gt_output}")
    
    ffmpeg_command = [
        # ffmpeg
        r'C:\ffmpeg\bin\ffmpeg.exe',
        '-framerate', str(30),
        '-i', os.path.join(gt_output, "img_%04d.png"),
        '-c:v', 'libx264',
        '-pix_fmt', 'yuv420p',
        output_video
    ]
    
    my_env = os.environ.copy()

    try:
        # Set working directory to ensure correct relative paths
        result = subprocess.run(
            ffmpeg_command,
            check=True,
            env=my_env,
            stderr=subprocess.PIPE,
            stdout=subprocess.PIPE,
            text=True
        )
        print(f"Video created successfully: {output_video}")
        return True
    except subprocess.CalledProcessError as e:
        print(f"Error creating video: {e}")
        print(f"ffmpeg stderr: {e.stderr}")
        return False
