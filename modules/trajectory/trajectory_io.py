"""
Module for reading and writing trajectory related files
"""
from typing import Dict, List
import numpy as np
import os
import json
from mathutils import Vector, Quaternion

camera_trajectory_header = [
        "# camera_traj_v2.txt (inertial frame reference - orbital configuration)",
        "# p_G_I(xyz)  q_I_G(wxyz)  p_C_I(xyz)  q_I_C(wxyz)  sun_az  sun_el",
        "Trajectory generated by the generateTrajectoriesUnified.py script",
        "# Earth/atmosphere at origin with fixed orientation",
        "#"
    ]

def write_camera_trajectory(output_dir: str,
                            nbSteps: int,
                            r_GO_I: np.ndarray, # vector from O to G in inertial frame
                            q_IG: np.ndarray, # quaternion from G to I
                            r_CO_I: np.ndarray, # vector from O to C in inertial frame
                            q_IC: np.ndarray, # quaternion from C to I
                            sun_az: float,
                            sun_el: float,
                            ) -> str:
    """
    Write camera_traj.txt for Blender import.
    a data structure to hold everything may be a good idea

    File format (one row per frame):
    p_G_I(xyz)  q_I_G(wxyz)  p_C_I(xyz)  q_I_C(wxyz)  sun_az  sun_el

    Note the frame conventions here follow the Trajectory generation standard
    
    Where:
      p_G_I = position of target (G) in inertial frame at radius R_LEO
      q_I_G = orientation of target frame relative to inertial
      p_C_I = position of camera (C) in inertial frame at radius (R_LEO + R_RPO)
      q_I_C = orientation of camera frame relative to inertial
    """
    camera_traj_filepath = os.path.join(output_dir, "camera_traj.txt")

    lines = []
    lines.extend(camera_trajectory_header)

    for i in range(nbSteps):
        p_G_I = r_GO_I[i]
        q_I_G = q_IG[i]
        p_C_I = r_CO_I[i]
        q_I_C = q_IC[i]

        line = (
            f"{p_G_I[0]:.6f} {p_G_I[1]:.6f} {p_G_I[2]:.6f} " # p_G_I
            f"{q_I_G[0]:.6f} {q_I_G[1]:.6f} {q_I_G[2]:.6f} {q_I_G[3]:.6f} " # q_I_G
            f"{p_C_I[0]:.6f} {p_C_I[1]:.6f} {p_C_I[2]:.6f} " # p_C_I
            f"{q_I_C[0]:.6f} {q_I_C[1]:.6f} {q_I_C[2]:.6f} {q_I_C[3]:.6f} " # q_I_C
            f"{sun_az:.6f} {sun_el:.6f}"
        )
        lines.append(line)

    with open(camera_traj_filepath, "w") as f:
        f.write("\n".join(lines)) # write all of the lines
        f.write("\n")  # ensure newline at end of file

    return camera_traj_filepath


def read_camera_trajectory_to_frames(path: str) -> List[Dict]:
    """
    Load trajectory from v2 file (inertial frame reference).
    
    File format (per line):
      p_G_I(3)  q_I_G(4)  p_C_I(3)  q_I_C(4)  sun_az(1)  sun_el(1)
      = 16 floats total per line
    
    Returns list of dicts with keys:
      p_G_I: position of target in inertial frame
      q_I_G: orientation of target relative to inertial
      p_C_I: position of camera in inertial frame
      q_I_C: orientation of camera relative to inertial
      sun_az, sun_el: sun angles
    """
    traj = []
    with open(path, "r") as f:
        for line_num, ln in enumerate(f, 1):
            ln = ln.strip()
            if not ln or ln.startswith("#"):
                continue
            
            parts = [float(x) for x in ln.split()]
            if len(parts) < 14:
                raise ValueError(f"Line {line_num}: Expected 14 floats, got {len(parts)}")
            
            # Parse: p_G_I(3) q_I_G(4) p_C_I(3) q_I_C(4) sun_az sun_el
            p_G_I = Vector((parts[0], parts[1], parts[2]))
            q_I_G = Quaternion((parts[3], parts[4], parts[5], parts[6])).normalized()
            p_C_I = Vector((parts[7], parts[8], parts[9]))
            q_I_C = Quaternion((parts[10], parts[11], parts[12], parts[13])).normalized()
            
            traj.append({
                "p_G_I": p_G_I,
                "q_I_G": q_I_G,
                "p_C_I": p_C_I,
                "q_I_C": q_I_C,
            })
    
    return traj
